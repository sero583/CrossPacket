<?php
// Auto-generated by CrossPacket - do not modify manually

declare(strict_types=1);

namespace App\DataPackets;

use DateTimeImmutable;
use DateTimeInterface;
use JsonSerializable;

/**
 * Response to a ping packet
 */
class PongPacket implements JsonSerializable
{
    public const TYPE = '/example/PongPacket';

    /** @var ?DateTimeImmutable Timestamp from the original ping */
    private ?DateTimeImmutable $original_timestamp = null;
    /** @var ?DateTimeImmutable When the pong was sent */
    private ?DateTimeImmutable $response_timestamp = null;
    /** @var ?int Calculated latency in milliseconds */
    private ?int $latency_ms = null;

    public function __construct(
        ?DateTimeImmutable $original_timestamp = null,
        ?DateTimeImmutable $response_timestamp = null,
        ?int $latency_ms = null
    )
    {
        $this->original_timestamp = $original_timestamp;
        $this->response_timestamp = $response_timestamp;
        $this->latency_ms = $latency_ms;
    }

    public function getOriginalTimestamp(): ?DateTimeImmutable
    {
        return $this->original_timestamp;
    }

    public function setOriginalTimestamp(DateTimeImmutable $original_timestamp): self
    {
        $this->original_timestamp = $original_timestamp;
        return $this;
    }

    public function getResponseTimestamp(): ?DateTimeImmutable
    {
        return $this->response_timestamp;
    }

    public function setResponseTimestamp(DateTimeImmutable $response_timestamp): self
    {
        $this->response_timestamp = $response_timestamp;
        return $this;
    }

    public function getLatencyMs(): ?int
    {
        return $this->latency_ms;
    }

    public function setLatencyMs(int $latency_ms): self
    {
        $this->latency_ms = $latency_ms;
        return $this;
    }

    public function jsonSerialize(): array
    {
        return [
            'packetType' => self::TYPE,
            'original_timestamp' => $this->original_timestamp?->format(\DateTimeInterface::ATOM),
            'response_timestamp' => $this->response_timestamp?->format(\DateTimeInterface::ATOM),
            'latency_ms' => $this->latency_ms,
        ];
    }

    public function toJson(): string
    {
        return json_encode($this->jsonSerialize(), JSON_THROW_ON_ERROR);
    }

    public static function fromJson(string $json): self
    {
        $data = json_decode($json, true, 512, JSON_THROW_ON_ERROR);
        $instance = new self();
        if (isset($data['original_timestamp'])) {
            $instance->setOriginalTimestamp(new \DateTimeImmutable($data['original_timestamp']));
        }
        if (isset($data['response_timestamp'])) {
            $instance->setResponseTimestamp(new \DateTimeImmutable($data['response_timestamp']));
        }
        if (isset($data['latency_ms'])) {
            $instance->setLatencyMs($data['latency_ms']);
        }
        return $instance;
    }

    public function toMsgPack(): string
    {
        return msgpack_pack($this->jsonSerialize());
    }

    public static function fromMsgPack(string $data): self
    {
        $arr = msgpack_unpack($data);
        $instance = new self();
        if (isset($arr['original_timestamp'])) {
            $instance->setOriginalTimestamp(new \DateTimeImmutable($arr['original_timestamp']));
        }
        if (isset($arr['response_timestamp'])) {
            $instance->setResponseTimestamp(new \DateTimeImmutable($arr['response_timestamp']));
        }
        if (isset($arr['latency_ms'])) {
            $instance->setLatencyMs($arr['latency_ms']);
        }
        return $instance;
    }
}