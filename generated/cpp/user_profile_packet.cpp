// Auto-generated by CrossPacket - do not modify manually
#include "user_profile_packet.hpp"
#include <cstdlib>

namespace packets {

UserProfilePacket::UserProfilePacket(int64_t user_id, const std::string& username, const std::string& email, const std::optional<std::string>& bio, const std::optional<int64_t>& age, double balance, const std::vector<std::string>& tags, const std::string& preferences, const std::optional<std::vector<uint8_t>>& avatar, const std::string& created_at, const std::optional<std::string>& last_login)
    : user_id_(user_id), username_(username), email_(email), bio_(bio), age_(age), balance_(balance), tags_(tags), preferences_(preferences), avatar_(avatar), created_at_(created_at), last_login_(last_login) {}

std::string UserProfilePacket::ToJson() const {
    yyjson_mut_doc* doc = yyjson_mut_doc_new(nullptr);
    yyjson_mut_val* root = yyjson_mut_obj(doc);
    yyjson_mut_doc_set_root(doc, root);

    yyjson_mut_obj_add_str(doc, root, "packetType", TYPE);
    yyjson_mut_obj_add_int(doc, root, "user_id", user_id_);
    yyjson_mut_obj_add_strcpy(doc, root, "username", username_.c_str());
    yyjson_mut_obj_add_strcpy(doc, root, "email", email_.c_str());
    if (bio_.has_value()) {
        yyjson_mut_obj_add_strcpy(doc, root, "bio", bio_.value().c_str());
    } else {
        yyjson_mut_obj_add_null(doc, root, "bio");
    }
    if (age_.has_value()) {
        yyjson_mut_obj_add_int(doc, root, "age", age_.value());
    } else {
        yyjson_mut_obj_add_null(doc, root, "age");
    }
    yyjson_mut_obj_add_real(doc, root, "balance", balance_);
    {
        yyjson_mut_val* arr = yyjson_mut_arr(doc);
        for (const auto& item : tags_) {
            yyjson_mut_arr_add_strcpy(doc, arr, item.c_str());
        }
        yyjson_mut_obj_add_val(doc, root, "tags", arr);
    }
    {
        yyjson_doc* sub_doc = yyjson_read(preferences_.c_str(), preferences_.size(), 0);
        if (sub_doc) {
            yyjson_val* sub_root = yyjson_doc_get_root(sub_doc);
            yyjson_mut_val* copied = yyjson_val_mut_copy(doc, sub_root);
            yyjson_mut_obj_add_val(doc, root, "preferences", copied);
            yyjson_doc_free(sub_doc);
        } else {
            yyjson_mut_obj_add_null(doc, root, "preferences");
        }
    }
    if (avatar_.has_value()) {
        {
            std::string encoded;
            static const char* chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            const auto& bytes = avatar_.value();
            size_t len = bytes.size();
            for (size_t i = 0; i < len; i += 3) {
                uint32_t octet_a = bytes[i];
                uint32_t octet_b = (i + 1 < len) ? bytes[i + 1] : 0;
                uint32_t octet_c = (i + 2 < len) ? bytes[i + 2] : 0;
                uint32_t triple = (octet_a << 16) | (octet_b << 8) | octet_c;
                encoded += chars[(triple >> 18) & 0x3F];
                encoded += chars[(triple >> 12) & 0x3F];
                encoded += (i + 1 < len) ? chars[(triple >> 6) & 0x3F] : '=';
                encoded += (i + 2 < len) ? chars[triple & 0x3F] : '=';
            }
            yyjson_mut_obj_add_strcpy(doc, root, "avatar", encoded.c_str());
        }
    } else {
        yyjson_mut_obj_add_null(doc, root, "avatar");
    }
    yyjson_mut_obj_add_strcpy(doc, root, "created_at", created_at_.c_str());
    if (last_login_.has_value()) {
        yyjson_mut_obj_add_strcpy(doc, root, "last_login", last_login_.value().c_str());
    } else {
        yyjson_mut_obj_add_null(doc, root, "last_login");
    }

    char* json = yyjson_mut_write(doc, 0, nullptr);
    std::string result(json);
    free(json);
    yyjson_mut_doc_free(doc);
    return result;
}

UserProfilePacket UserProfilePacket::FromJson(const std::string& json) {
    yyjson_doc* doc = yyjson_read(json.c_str(), json.size(), 0);
    if (!doc) {
        throw std::runtime_error("JSON parse error");
    }

    yyjson_val* root = yyjson_doc_get_root(doc);
    UserProfilePacket packet;

    yyjson_val* user_id_val = yyjson_obj_get(root, "user_id");
    if (user_id_val && yyjson_is_int(user_id_val)) {
        packet.user_id_ = yyjson_get_sint(user_id_val);
    }
    yyjson_val* username_val = yyjson_obj_get(root, "username");
    if (username_val && yyjson_is_str(username_val)) {
        packet.username_ = yyjson_get_str(username_val);
    }
    yyjson_val* email_val = yyjson_obj_get(root, "email");
    if (email_val && yyjson_is_str(email_val)) {
        packet.email_ = yyjson_get_str(email_val);
    }
    yyjson_val* bio_val = yyjson_obj_get(root, "bio");
    if (bio_val && yyjson_is_str(bio_val)) {
        packet.bio_ = yyjson_get_str(bio_val);
    }
    yyjson_val* age_val = yyjson_obj_get(root, "age");
    if (age_val && yyjson_is_int(age_val)) {
        packet.age_ = yyjson_get_sint(age_val);
    }
    yyjson_val* balance_val = yyjson_obj_get(root, "balance");
    if (balance_val && (yyjson_is_real(balance_val) || yyjson_is_int(balance_val))) {
        packet.balance_ = yyjson_get_num(balance_val);
    }
    yyjson_val* tags_val = yyjson_obj_get(root, "tags");
    if (tags_val && yyjson_is_arr(tags_val)) {
        size_t idx, max;
        yyjson_val* item;
        yyjson_arr_foreach(tags_val, idx, max, item) {
            if (yyjson_is_str(item)) {
                packet.tags_.push_back(yyjson_get_str(item));
            }
        }
    }
    yyjson_val* preferences_val = yyjson_obj_get(root, "preferences");
    if (preferences_val) {
        char* sub_json = yyjson_val_write(preferences_val, 0, nullptr);
        if (sub_json) {
            packet.preferences_ = sub_json;
            free(sub_json);
        }
    }
    yyjson_val* avatar_val = yyjson_obj_get(root, "avatar");
    if (avatar_val && yyjson_is_str(avatar_val)) {
        const char* encoded = yyjson_get_str(avatar_val);
        if (encoded && *encoded) {
            std::vector<unsigned char> decoded;
            static const int decode_table[256] = {
                -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
                -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62,-1,-1,-1,63,52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-1,-1,-1,
                -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,
                -1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,-1,-1,-1,-1,-1
            };
            size_t len = strlen(encoded);
            for (size_t i = 0; i < len; i += 4) {
                int a = decode_table[(unsigned char)encoded[i]];
                int b = (i+1 < len) ? decode_table[(unsigned char)encoded[i+1]] : 0;
                int c = (i+2 < len && encoded[i+2] != '=') ? decode_table[(unsigned char)encoded[i+2]] : 0;
                int d = (i+3 < len && encoded[i+3] != '=') ? decode_table[(unsigned char)encoded[i+3]] : 0;
                decoded.push_back((a << 2) | (b >> 4));
                if (i+2 < len && encoded[i+2] != '=') decoded.push_back(((b & 0xF) << 4) | (c >> 2));
                if (i+3 < len && encoded[i+3] != '=') decoded.push_back(((c & 0x3) << 6) | d);
            }
            packet.avatar_ = decoded;
        }
    }
    yyjson_val* created_at_val = yyjson_obj_get(root, "created_at");
    if (created_at_val && yyjson_is_str(created_at_val)) {
        packet.created_at_ = yyjson_get_str(created_at_val);
    }
    yyjson_val* last_login_val = yyjson_obj_get(root, "last_login");
    if (last_login_val && yyjson_is_str(last_login_val)) {
        packet.last_login_ = yyjson_get_str(last_login_val);
    }

    yyjson_doc_free(doc);
    return packet;
}

std::vector<uint8_t> UserProfilePacket::ToMsgPack() const {
    msgpack::sbuffer buffer;
    msgpack::pack(buffer, *this);
    return std::vector<uint8_t>(buffer.data(), buffer.data() + buffer.size());
}

UserProfilePacket UserProfilePacket::FromMsgPack(const std::vector<uint8_t>& data) {
    msgpack::object_handle oh = msgpack::unpack(reinterpret_cast<const char*>(data.data()), data.size());
    return oh.get().as<UserProfilePacket>();
}

} // namespace packets