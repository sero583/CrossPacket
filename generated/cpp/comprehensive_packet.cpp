// Auto-generated by CrossPacket - do not modify manually
#include "comprehensive_packet.hpp"
#include <cstdlib>

namespace packets {

ComprehensivePacket::ComprehensivePacket(int64_t int_field, double float_field, double double_field, const std::string& string_field, bool bool_field, const std::string& datetime_field, const std::string& time_field, const std::string& list_field, const std::vector<int64_t>& list_int_field, const std::vector<std::string>& list_string_field, const std::string& map_field, const std::string& embedded_map_field, const std::string& map_string_dynamic_field, const std::vector<uint8_t>& bytes_field)
    : int_field_(int_field), float_field_(float_field), double_field_(double_field), string_field_(string_field), bool_field_(bool_field), datetime_field_(datetime_field), time_field_(time_field), list_field_(list_field), list_int_field_(list_int_field), list_string_field_(list_string_field), map_field_(map_field), embedded_map_field_(embedded_map_field), map_string_dynamic_field_(map_string_dynamic_field), bytes_field_(bytes_field) {}

std::string ComprehensivePacket::ToJson() const {
    yyjson_mut_doc* doc = yyjson_mut_doc_new(nullptr);
    yyjson_mut_val* root = yyjson_mut_obj(doc);
    yyjson_mut_doc_set_root(doc, root);

    yyjson_mut_obj_add_str(doc, root, "packetType", TYPE);
    yyjson_mut_obj_add_int(doc, root, "int_field", int_field_);
    yyjson_mut_obj_add_real(doc, root, "float_field", float_field_);
    yyjson_mut_obj_add_real(doc, root, "double_field", double_field_);
    yyjson_mut_obj_add_strcpy(doc, root, "string_field", string_field_.c_str());
    yyjson_mut_obj_add_bool(doc, root, "bool_field", bool_field_);
    yyjson_mut_obj_add_strcpy(doc, root, "datetime_field", datetime_field_.c_str());
    yyjson_mut_obj_add_strcpy(doc, root, "time_field", time_field_.c_str());
    {
        yyjson_doc* sub_doc = yyjson_read(list_field_.c_str(), list_field_.size(), 0);
        if (sub_doc) {
            yyjson_val* sub_root = yyjson_doc_get_root(sub_doc);
            yyjson_mut_val* copied = yyjson_val_mut_copy(doc, sub_root);
            yyjson_mut_obj_add_val(doc, root, "list_field", copied);
            yyjson_doc_free(sub_doc);
        } else {
            yyjson_mut_obj_add_null(doc, root, "list_field");
        }
    }
    {
        yyjson_mut_val* arr = yyjson_mut_arr(doc);
        for (const auto& item : list_int_field_) {
            yyjson_mut_arr_add_int(doc, arr, item);
        }
        yyjson_mut_obj_add_val(doc, root, "list_int_field", arr);
    }
    {
        yyjson_mut_val* arr = yyjson_mut_arr(doc);
        for (const auto& item : list_string_field_) {
            yyjson_mut_arr_add_strcpy(doc, arr, item.c_str());
        }
        yyjson_mut_obj_add_val(doc, root, "list_string_field", arr);
    }
    {
        yyjson_doc* sub_doc = yyjson_read(map_field_.c_str(), map_field_.size(), 0);
        if (sub_doc) {
            yyjson_val* sub_root = yyjson_doc_get_root(sub_doc);
            yyjson_mut_val* copied = yyjson_val_mut_copy(doc, sub_root);
            yyjson_mut_obj_add_val(doc, root, "map_field", copied);
            yyjson_doc_free(sub_doc);
        } else {
            yyjson_mut_obj_add_null(doc, root, "map_field");
        }
    }
    {
        yyjson_doc* sub_doc = yyjson_read(embedded_map_field_.c_str(), embedded_map_field_.size(), 0);
        if (sub_doc) {
            yyjson_val* sub_root = yyjson_doc_get_root(sub_doc);
            yyjson_mut_val* copied = yyjson_val_mut_copy(doc, sub_root);
            yyjson_mut_obj_add_val(doc, root, "embedded_map_field", copied);
            yyjson_doc_free(sub_doc);
        } else {
            yyjson_mut_obj_add_null(doc, root, "embedded_map_field");
        }
    }
    {
        yyjson_doc* sub_doc = yyjson_read(map_string_dynamic_field_.c_str(), map_string_dynamic_field_.size(), 0);
        if (sub_doc) {
            yyjson_val* sub_root = yyjson_doc_get_root(sub_doc);
            yyjson_mut_val* copied = yyjson_val_mut_copy(doc, sub_root);
            yyjson_mut_obj_add_val(doc, root, "map_string_dynamic_field", copied);
            yyjson_doc_free(sub_doc);
        } else {
            yyjson_mut_obj_add_null(doc, root, "map_string_dynamic_field");
        }
    }
    {
        std::string encoded;
        static const char* chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        const auto& bytes = bytes_field_;
        size_t len = bytes.size();
        for (size_t i = 0; i < len; i += 3) {
            uint32_t octet_a = bytes[i];
            uint32_t octet_b = (i + 1 < len) ? bytes[i + 1] : 0;
            uint32_t octet_c = (i + 2 < len) ? bytes[i + 2] : 0;
            uint32_t triple = (octet_a << 16) | (octet_b << 8) | octet_c;
            encoded += chars[(triple >> 18) & 0x3F];
            encoded += chars[(triple >> 12) & 0x3F];
            encoded += (i + 1 < len) ? chars[(triple >> 6) & 0x3F] : '=';
            encoded += (i + 2 < len) ? chars[triple & 0x3F] : '=';
        }
        yyjson_mut_obj_add_strcpy(doc, root, "bytes_field", encoded.c_str());
    }

    char* json = yyjson_mut_write(doc, 0, nullptr);
    std::string result(json);
    free(json);
    yyjson_mut_doc_free(doc);
    return result;
}

ComprehensivePacket ComprehensivePacket::FromJson(const std::string& json) {
    yyjson_doc* doc = yyjson_read(json.c_str(), json.size(), 0);
    if (!doc) {
        throw std::runtime_error("JSON parse error");
    }

    yyjson_val* root = yyjson_doc_get_root(doc);
    ComprehensivePacket packet;

    yyjson_val* int_field_val = yyjson_obj_get(root, "int_field");
    if (int_field_val && yyjson_is_int(int_field_val)) {
        packet.int_field_ = yyjson_get_sint(int_field_val);
    }
    yyjson_val* float_field_val = yyjson_obj_get(root, "float_field");
    if (float_field_val && (yyjson_is_real(float_field_val) || yyjson_is_int(float_field_val))) {
        packet.float_field_ = yyjson_get_num(float_field_val);
    }
    yyjson_val* double_field_val = yyjson_obj_get(root, "double_field");
    if (double_field_val && (yyjson_is_real(double_field_val) || yyjson_is_int(double_field_val))) {
        packet.double_field_ = yyjson_get_num(double_field_val);
    }
    yyjson_val* string_field_val = yyjson_obj_get(root, "string_field");
    if (string_field_val && yyjson_is_str(string_field_val)) {
        packet.string_field_ = yyjson_get_str(string_field_val);
    }
    yyjson_val* bool_field_val = yyjson_obj_get(root, "bool_field");
    if (bool_field_val && yyjson_is_bool(bool_field_val)) {
        packet.bool_field_ = yyjson_get_bool(bool_field_val);
    }
    yyjson_val* datetime_field_val = yyjson_obj_get(root, "datetime_field");
    if (datetime_field_val && yyjson_is_str(datetime_field_val)) {
        packet.datetime_field_ = yyjson_get_str(datetime_field_val);
    }
    yyjson_val* time_field_val = yyjson_obj_get(root, "time_field");
    if (time_field_val && yyjson_is_str(time_field_val)) {
        packet.time_field_ = yyjson_get_str(time_field_val);
    }
    yyjson_val* list_field_val = yyjson_obj_get(root, "list_field");
    if (list_field_val) {
        char* sub_json = yyjson_val_write(list_field_val, 0, nullptr);
        if (sub_json) {
            packet.list_field_ = sub_json;
            free(sub_json);
        }
    }
    yyjson_val* list_int_field_val = yyjson_obj_get(root, "list_int_field");
    if (list_int_field_val && yyjson_is_arr(list_int_field_val)) {
        size_t idx, max;
        yyjson_val* item;
        yyjson_arr_foreach(list_int_field_val, idx, max, item) {
            if (yyjson_is_int(item)) {
                packet.list_int_field_.push_back(yyjson_get_sint(item));
            }
        }
    }
    yyjson_val* list_string_field_val = yyjson_obj_get(root, "list_string_field");
    if (list_string_field_val && yyjson_is_arr(list_string_field_val)) {
        size_t idx, max;
        yyjson_val* item;
        yyjson_arr_foreach(list_string_field_val, idx, max, item) {
            if (yyjson_is_str(item)) {
                packet.list_string_field_.push_back(yyjson_get_str(item));
            }
        }
    }
    yyjson_val* map_field_val = yyjson_obj_get(root, "map_field");
    if (map_field_val) {
        char* sub_json = yyjson_val_write(map_field_val, 0, nullptr);
        if (sub_json) {
            packet.map_field_ = sub_json;
            free(sub_json);
        }
    }
    yyjson_val* embedded_map_field_val = yyjson_obj_get(root, "embedded_map_field");
    if (embedded_map_field_val) {
        char* sub_json = yyjson_val_write(embedded_map_field_val, 0, nullptr);
        if (sub_json) {
            packet.embedded_map_field_ = sub_json;
            free(sub_json);
        }
    }
    yyjson_val* map_string_dynamic_field_val = yyjson_obj_get(root, "map_string_dynamic_field");
    if (map_string_dynamic_field_val) {
        char* sub_json = yyjson_val_write(map_string_dynamic_field_val, 0, nullptr);
        if (sub_json) {
            packet.map_string_dynamic_field_ = sub_json;
            free(sub_json);
        }
    }
    yyjson_val* bytes_field_val = yyjson_obj_get(root, "bytes_field");
    if (bytes_field_val && yyjson_is_str(bytes_field_val)) {
        const char* encoded = yyjson_get_str(bytes_field_val);
        if (encoded && *encoded) {
            std::vector<unsigned char> decoded;
            static const int decode_table[256] = {
                -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
                -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62,-1,-1,-1,63,52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-1,-1,-1,
                -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,
                -1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,-1,-1,-1,-1,-1
            };
            size_t len = strlen(encoded);
            for (size_t i = 0; i < len; i += 4) {
                int a = decode_table[(unsigned char)encoded[i]];
                int b = (i+1 < len) ? decode_table[(unsigned char)encoded[i+1]] : 0;
                int c = (i+2 < len && encoded[i+2] != '=') ? decode_table[(unsigned char)encoded[i+2]] : 0;
                int d = (i+3 < len && encoded[i+3] != '=') ? decode_table[(unsigned char)encoded[i+3]] : 0;
                decoded.push_back((a << 2) | (b >> 4));
                if (i+2 < len && encoded[i+2] != '=') decoded.push_back(((b & 0xF) << 4) | (c >> 2));
                if (i+3 < len && encoded[i+3] != '=') decoded.push_back(((c & 0x3) << 6) | d);
            }
            packet.bytes_field_ = decoded;
        }
    }

    yyjson_doc_free(doc);
    return packet;
}

std::vector<uint8_t> ComprehensivePacket::ToMsgPack() const {
    msgpack::sbuffer buffer;
    msgpack::pack(buffer, *this);
    return std::vector<uint8_t>(buffer.data(), buffer.data() + buffer.size());
}

ComprehensivePacket ComprehensivePacket::FromMsgPack(const std::vector<uint8_t>& data) {
    msgpack::object_handle oh = msgpack::unpack(reinterpret_cast<const char*>(data.data()), data.size());
    return oh.get().as<ComprehensivePacket>();
}

} // namespace packets