// Auto-generated by CrossPacket - do not modify manually
#include "ping_packet.hpp"
#include <cstdlib>

namespace packets {

PingPacket::PingPacket(const std::string& timestamp, const std::string& message)
    : timestamp_(timestamp), message_(message) {}

std::string PingPacket::ToJson() const {
    yyjson_mut_doc* doc = yyjson_mut_doc_new(nullptr);
    yyjson_mut_val* root = yyjson_mut_obj(doc);
    yyjson_mut_doc_set_root(doc, root);

    yyjson_mut_obj_add_str(doc, root, "packetType", TYPE);
    yyjson_mut_obj_add_strcpy(doc, root, "timestamp", timestamp_.c_str());
    yyjson_mut_obj_add_strcpy(doc, root, "message", message_.c_str());

    char* json = yyjson_mut_write(doc, 0, nullptr);
    std::string result(json);
    free(json);
    yyjson_mut_doc_free(doc);
    return result;
}

PingPacket PingPacket::FromJson(const std::string& json) {
    yyjson_doc* doc = yyjson_read(json.c_str(), json.size(), 0);
    if (!doc) {
        throw std::runtime_error("JSON parse error");
    }

    yyjson_val* root = yyjson_doc_get_root(doc);
    PingPacket packet;

    yyjson_val* timestamp_val = yyjson_obj_get(root, "timestamp");
    if (timestamp_val && yyjson_is_str(timestamp_val)) {
        packet.timestamp_ = yyjson_get_str(timestamp_val);
    }
    yyjson_val* message_val = yyjson_obj_get(root, "message");
    if (message_val && yyjson_is_str(message_val)) {
        packet.message_ = yyjson_get_str(message_val);
    }

    yyjson_doc_free(doc);
    return packet;
}

std::vector<uint8_t> PingPacket::ToMsgPack() const {
    msgpack::sbuffer buffer;
    msgpack::pack(buffer, *this);
    return std::vector<uint8_t>(buffer.data(), buffer.data() + buffer.size());
}

PingPacket PingPacket::FromMsgPack(const std::vector<uint8_t>& data) {
    msgpack::object_handle oh = msgpack::unpack(reinterpret_cast<const char*>(data.data()), data.size());
    return oh.get().as<PingPacket>();
}

} // namespace packets