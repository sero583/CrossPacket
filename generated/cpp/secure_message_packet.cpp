// Auto-generated by CrossPacket - do not modify manually
#include "secure_message_packet.hpp"
#include <cstdlib>

namespace packets {

SecureMessagePacket::SecureMessagePacket(const std::string& message_id, int64_t sender_id, int64_t recipient_id, const std::string& subject, const std::string& body, const std::string& attachments, const std::optional<std::vector<uint8_t>>& encrypted_payload, int64_t priority, bool is_read, const std::string& sent_at)
    : message_id_(message_id), sender_id_(sender_id), recipient_id_(recipient_id), subject_(subject), body_(body), attachments_(attachments), encrypted_payload_(encrypted_payload), priority_(priority), is_read_(is_read), sent_at_(sent_at) {}

std::string SecureMessagePacket::ToJson() const {
    yyjson_mut_doc* doc = yyjson_mut_doc_new(nullptr);
    yyjson_mut_val* root = yyjson_mut_obj(doc);
    yyjson_mut_doc_set_root(doc, root);

    yyjson_mut_obj_add_str(doc, root, "packetType", TYPE);
    yyjson_mut_obj_add_strcpy(doc, root, "message_id", message_id_.c_str());
    yyjson_mut_obj_add_int(doc, root, "sender_id", sender_id_);
    yyjson_mut_obj_add_int(doc, root, "recipient_id", recipient_id_);
    yyjson_mut_obj_add_strcpy(doc, root, "subject", subject_.c_str());
    yyjson_mut_obj_add_strcpy(doc, root, "body", body_.c_str());
    {
        yyjson_doc* sub_doc = yyjson_read(attachments_.c_str(), attachments_.size(), 0);
        if (sub_doc) {
            yyjson_val* sub_root = yyjson_doc_get_root(sub_doc);
            yyjson_mut_val* copied = yyjson_val_mut_copy(doc, sub_root);
            yyjson_mut_obj_add_val(doc, root, "attachments", copied);
            yyjson_doc_free(sub_doc);
        } else {
            yyjson_mut_obj_add_null(doc, root, "attachments");
        }
    }
    if (encrypted_payload_.has_value()) {
        {
            std::string encoded;
            static const char* chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            const auto& bytes = encrypted_payload_.value();
            size_t len = bytes.size();
            for (size_t i = 0; i < len; i += 3) {
                uint32_t octet_a = bytes[i];
                uint32_t octet_b = (i + 1 < len) ? bytes[i + 1] : 0;
                uint32_t octet_c = (i + 2 < len) ? bytes[i + 2] : 0;
                uint32_t triple = (octet_a << 16) | (octet_b << 8) | octet_c;
                encoded += chars[(triple >> 18) & 0x3F];
                encoded += chars[(triple >> 12) & 0x3F];
                encoded += (i + 1 < len) ? chars[(triple >> 6) & 0x3F] : '=';
                encoded += (i + 2 < len) ? chars[triple & 0x3F] : '=';
            }
            yyjson_mut_obj_add_strcpy(doc, root, "encrypted_payload", encoded.c_str());
        }
    } else {
        yyjson_mut_obj_add_null(doc, root, "encrypted_payload");
    }
    yyjson_mut_obj_add_int(doc, root, "priority", priority_);
    yyjson_mut_obj_add_bool(doc, root, "is_read", is_read_);
    yyjson_mut_obj_add_strcpy(doc, root, "sent_at", sent_at_.c_str());

    char* json = yyjson_mut_write(doc, 0, nullptr);
    std::string result(json);
    free(json);
    yyjson_mut_doc_free(doc);
    return result;
}

SecureMessagePacket SecureMessagePacket::FromJson(const std::string& json) {
    yyjson_doc* doc = yyjson_read(json.c_str(), json.size(), 0);
    if (!doc) {
        throw std::runtime_error("JSON parse error");
    }

    yyjson_val* root = yyjson_doc_get_root(doc);
    SecureMessagePacket packet;

    yyjson_val* message_id_val = yyjson_obj_get(root, "message_id");
    if (message_id_val && yyjson_is_str(message_id_val)) {
        packet.message_id_ = yyjson_get_str(message_id_val);
    }
    yyjson_val* sender_id_val = yyjson_obj_get(root, "sender_id");
    if (sender_id_val && yyjson_is_int(sender_id_val)) {
        packet.sender_id_ = yyjson_get_sint(sender_id_val);
    }
    yyjson_val* recipient_id_val = yyjson_obj_get(root, "recipient_id");
    if (recipient_id_val && yyjson_is_int(recipient_id_val)) {
        packet.recipient_id_ = yyjson_get_sint(recipient_id_val);
    }
    yyjson_val* subject_val = yyjson_obj_get(root, "subject");
    if (subject_val && yyjson_is_str(subject_val)) {
        packet.subject_ = yyjson_get_str(subject_val);
    }
    yyjson_val* body_val = yyjson_obj_get(root, "body");
    if (body_val && yyjson_is_str(body_val)) {
        packet.body_ = yyjson_get_str(body_val);
    }
    yyjson_val* attachments_val = yyjson_obj_get(root, "attachments");
    if (attachments_val) {
        char* sub_json = yyjson_val_write(attachments_val, 0, nullptr);
        if (sub_json) {
            packet.attachments_ = sub_json;
            free(sub_json);
        }
    }
    yyjson_val* encrypted_payload_val = yyjson_obj_get(root, "encrypted_payload");
    if (encrypted_payload_val && yyjson_is_str(encrypted_payload_val)) {
        const char* encoded = yyjson_get_str(encrypted_payload_val);
        if (encoded && *encoded) {
            std::vector<unsigned char> decoded;
            static const int decode_table[256] = {
                -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
                -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62,-1,-1,-1,63,52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-1,-1,-1,
                -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,
                -1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,-1,-1,-1,-1,-1
            };
            size_t len = strlen(encoded);
            for (size_t i = 0; i < len; i += 4) {
                int a = decode_table[(unsigned char)encoded[i]];
                int b = (i+1 < len) ? decode_table[(unsigned char)encoded[i+1]] : 0;
                int c = (i+2 < len && encoded[i+2] != '=') ? decode_table[(unsigned char)encoded[i+2]] : 0;
                int d = (i+3 < len && encoded[i+3] != '=') ? decode_table[(unsigned char)encoded[i+3]] : 0;
                decoded.push_back((a << 2) | (b >> 4));
                if (i+2 < len && encoded[i+2] != '=') decoded.push_back(((b & 0xF) << 4) | (c >> 2));
                if (i+3 < len && encoded[i+3] != '=') decoded.push_back(((c & 0x3) << 6) | d);
            }
            packet.encrypted_payload_ = decoded;
        }
    }
    yyjson_val* priority_val = yyjson_obj_get(root, "priority");
    if (priority_val && yyjson_is_int(priority_val)) {
        packet.priority_ = yyjson_get_sint(priority_val);
    }
    yyjson_val* is_read_val = yyjson_obj_get(root, "is_read");
    if (is_read_val && yyjson_is_bool(is_read_val)) {
        packet.is_read_ = yyjson_get_bool(is_read_val);
    }
    yyjson_val* sent_at_val = yyjson_obj_get(root, "sent_at");
    if (sent_at_val && yyjson_is_str(sent_at_val)) {
        packet.sent_at_ = yyjson_get_str(sent_at_val);
    }

    yyjson_doc_free(doc);
    return packet;
}

std::vector<uint8_t> SecureMessagePacket::ToMsgPack() const {
    msgpack::sbuffer buffer;
    msgpack::pack(buffer, *this);
    return std::vector<uint8_t>(buffer.data(), buffer.data() + buffer.size());
}

SecureMessagePacket SecureMessagePacket::FromMsgPack(const std::vector<uint8_t>& data) {
    msgpack::object_handle oh = msgpack::unpack(reinterpret_cast<const char*>(data.data()), data.size());
    return oh.get().as<SecureMessagePacket>();
}

} // namespace packets