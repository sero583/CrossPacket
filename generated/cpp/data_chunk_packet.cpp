// Auto-generated by CrossPacket - do not modify manually
#include "data_chunk_packet.hpp"
#include <cstdlib>

namespace packets {

DataChunkPacket::DataChunkPacket(int64_t chunk_index, int64_t total_chunks, const std::string& data, const std::string& checksum)
    : chunk_index_(chunk_index), total_chunks_(total_chunks), data_(data), checksum_(checksum) {}

std::string DataChunkPacket::ToJson() const {
    yyjson_mut_doc* doc = yyjson_mut_doc_new(nullptr);
    yyjson_mut_val* root = yyjson_mut_obj(doc);
    yyjson_mut_doc_set_root(doc, root);

    yyjson_mut_obj_add_str(doc, root, "packetType", TYPE);
    yyjson_mut_obj_add_int(doc, root, "chunk_index", chunk_index_);
    yyjson_mut_obj_add_int(doc, root, "total_chunks", total_chunks_);
    {
        yyjson_doc* sub_doc = yyjson_read(data_.c_str(), data_.size(), 0);
        if (sub_doc) {
            yyjson_val* sub_root = yyjson_doc_get_root(sub_doc);
            yyjson_mut_val* copied = yyjson_val_mut_copy(doc, sub_root);
            yyjson_mut_obj_add_val(doc, root, "data", copied);
            yyjson_doc_free(sub_doc);
        } else {
            yyjson_mut_obj_add_null(doc, root, "data");
        }
    }
    yyjson_mut_obj_add_strcpy(doc, root, "checksum", checksum_.c_str());

    char* json = yyjson_mut_write(doc, 0, nullptr);
    std::string result(json);
    free(json);
    yyjson_mut_doc_free(doc);
    return result;
}

DataChunkPacket DataChunkPacket::FromJson(const std::string& json) {
    yyjson_doc* doc = yyjson_read(json.c_str(), json.size(), 0);
    if (!doc) {
        throw std::runtime_error("JSON parse error");
    }

    yyjson_val* root = yyjson_doc_get_root(doc);
    DataChunkPacket packet;

    yyjson_val* chunk_index_val = yyjson_obj_get(root, "chunk_index");
    if (chunk_index_val && yyjson_is_int(chunk_index_val)) {
        packet.chunk_index_ = yyjson_get_sint(chunk_index_val);
    }
    yyjson_val* total_chunks_val = yyjson_obj_get(root, "total_chunks");
    if (total_chunks_val && yyjson_is_int(total_chunks_val)) {
        packet.total_chunks_ = yyjson_get_sint(total_chunks_val);
    }
    yyjson_val* data_val = yyjson_obj_get(root, "data");
    if (data_val) {
        char* sub_json = yyjson_val_write(data_val, 0, nullptr);
        if (sub_json) {
            packet.data_ = sub_json;
            free(sub_json);
        }
    }
    yyjson_val* checksum_val = yyjson_obj_get(root, "checksum");
    if (checksum_val && yyjson_is_str(checksum_val)) {
        packet.checksum_ = yyjson_get_str(checksum_val);
    }

    yyjson_doc_free(doc);
    return packet;
}

std::vector<uint8_t> DataChunkPacket::ToMsgPack() const {
    msgpack::sbuffer buffer;
    msgpack::pack(buffer, *this);
    return std::vector<uint8_t>(buffer.data(), buffer.data() + buffer.size());
}

DataChunkPacket DataChunkPacket::FromMsgPack(const std::vector<uint8_t>& data) {
    msgpack::object_handle oh = msgpack::unpack(reinterpret_cast<const char*>(data.data()), data.size());
    return oh.get().as<DataChunkPacket>();
}

} // namespace packets