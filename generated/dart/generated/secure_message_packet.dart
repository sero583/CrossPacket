// This file is auto-generated. Do not modify manually.
// Generated by CrossPacket
import 'dart:convert';
import 'dart:typed_data';
import 'package:msgpack_dart/msgpack_dart.dart' as msgpack;
import '../data_packet.dart';

/// Formats a DateTime with timezone offset (ISO 8601).
String _formatDateTimeWithTimezone(DateTime dt) {
  final offset = dt.timeZoneOffset;
  final offsetSign = offset.isNegative ? '-' : '+';
  final offsetHours = offset.abs().inHours.toString().padLeft(2, '0');
  final offsetMinutes = (offset.abs().inMinutes % 60).toString().padLeft(2, '0');
  final year = dt.year.toString().padLeft(4, '0');
  final month = dt.month.toString().padLeft(2, '0');
  final day = dt.day.toString().padLeft(2, '0');
  final hour = dt.hour.toString().padLeft(2, '0');
  final minute = dt.minute.toString().padLeft(2, '0');
  final second = dt.second.toString().padLeft(2, '0');
  final millisecond = dt.millisecond.toString().padLeft(3, '0');
  return '$year-$month-${day}T$hour:$minute:$second.$millisecond$offsetSign$offsetHours:$offsetMinutes';
}

/// Security-hardened message packet with strict validation
class SecureMessagePacket extends DataPacket {
  /// UUID message identifier
  String? message_id;
  /// Sender user ID
  int? sender_id;
  /// Recipient user ID
  int? recipient_id;
  /// Message subject (max 200 chars)
  String? subject;
  /// Message body (max 10000 chars)
  String? body;
  /// Attachment metadata (max 5 files)
  List<dynamic>? attachments;
  /// Encrypted message content (max 10MB)
  Uint8List? encrypted_payload;
  /// Message priority (1-5)
  int? priority;
  /// Read status flag
  bool? is_read;
  /// Send timestamp
  DateTime? sent_at;

  /// Creates an empty [SecureMessagePacket]. Use setters to populate fields.
  SecureMessagePacket();

  /// Creates a [SecureMessagePacket] with all fields.
  SecureMessagePacket.create({
    this.message_id,
    this.sender_id,
    this.recipient_id,
    this.subject,
    this.body,
    this.attachments,
    this.encrypted_payload,
    this.priority,
    this.is_read,
    this.sent_at,
  });

  @override
  String get type => '/example/SecureMessagePacket';

  @override
  Map<String, dynamic> serialize() => {
    'packetType': type,
    'message_id': message_id,
    'sender_id': sender_id,
    'recipient_id': recipient_id,
    'subject': subject,
    'body': body,
    'attachments': attachments,
    'encrypted_payload': encrypted_payload != null ? base64Encode(encrypted_payload!) : null,
    'priority': priority,
    'is_read': is_read,
    'sent_at': sent_at != null ? _formatDateTimeWithTimezone(sent_at!) : null,
  };

  /// Creates a [SecureMessagePacket] from a JSON map (internal helper).
  static SecureMessagePacket _fromMap(Map<String, dynamic> json) =>
    SecureMessagePacket.create(
      message_id: json['message_id'],
      sender_id: json['sender_id'],
      recipient_id: json['recipient_id'],
      subject: json['subject'],
      body: json['body'],
      attachments: json['attachments'] as List<dynamic>?,
      encrypted_payload: json['encrypted_payload'] != null ? base64Decode(json['encrypted_payload']) : null,
      priority: json['priority'],
      is_read: json['is_read'],
      sent_at: json['sent_at'] != null ? DateTime.parse(json['sent_at']) : null,
    );

  /// Serializes this packet to a JSON string.
  String toJson() => jsonEncode(serialize());

  /// Creates a [SecureMessagePacket] from a JSON string.
  static SecureMessagePacket fromJson(String jsonString) {
    return _fromMap(jsonDecode(jsonString) as Map<String, dynamic>);
  }

  /// Serializes this packet to MessagePack binary format.
  Uint8List toMsgPack() => msgpack.serialize(serialize());

  /// Creates a [SecureMessagePacket] from MessagePack binary data.
  static SecureMessagePacket fromMsgPack(Uint8List bytes) {
    final data = msgpack.deserialize(bytes);
    return _fromMap(Map<String, dynamic>.from(data as Map));
  }
}